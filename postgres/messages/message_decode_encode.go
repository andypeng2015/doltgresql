// Copyright 2023 Dolthub, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package messages

import (
	"bytes"
	"encoding/binary"
	"net"
)

// Receive returns a MessageType from the given buffer, generally generated by the client in the main read loop of a
// connection.
func Receive(buffer []byte) (MessageType, bool, error) {
	if len(buffer) == 0 {
		return nil, false, nil
	}
	message, ok := allMessageHeaders[buffer[0]]
	if !ok {
		return nil, false, nil
	}
	defaultMessage := message.defaultMessage()
	fields := defaultMessage.Copy().Fields
	decode(buffer, [][]*Field{fields}, 1)
	outMessage, err := message.decode(Message{defaultMessage.Name, fields, defaultMessage.info, false})
	return outMessage, true, err
}

// Send sends the given message over the connection.
func Send(conn net.Conn, message MessageType) error {
	encodedMessage, err := message.encode()
	if err != nil {
		return err
	}
	data, err := encode(encodedMessage)
	if err != nil {
		return err
	}
	_, err = conn.Write(data)
	return err
}

// decode writes the contents of the buffer into the given fields. The iteration count determines how many times the
// fields will be looped over.
func decode(buffer []byte, fields [][]*Field, iterations int32) {
	for iteration := int32(0); iteration < iterations; iteration++ {
		for _, field := range fields[iteration] {
			if len(buffer) == 0 {
				panic("buffer too small")
			}
			switch field.Type {
			case Byte1, Int8:
				field.Data = int32(buffer[0])
				buffer = buffer[1:]
			case ByteN:
				data := make([]byte, len(buffer))
				copy(data, buffer)
				field.Data = data
				buffer = nil
			case Int16:
				field.Data = int32(binary.BigEndian.Uint16(buffer))
				buffer = buffer[2:]
			case Int32:
				field.Data = int32(binary.BigEndian.Uint32(buffer))
				buffer = buffer[4:]
			case String:
				found := false
				for bufferIdx := range buffer {
					if buffer[bufferIdx] == 0 {
						field.Data = string(buffer[:bufferIdx])
						buffer = buffer[bufferIdx:]
						if field.Tags&ExcludeTerminator == 0 {
							buffer = buffer[1:]
						}
						found = true
						break
					}
				}
				if !found {
					panic("terminating zero not found for string")
				}
			default:
				panic("message type has not been defined")
			}

			if len(field.Children) > 0 {
				count, ok := field.Data.(int32)
				if !ok {
					panic("non-integer is being used as a count")
				}
				field.extend(int(count), field.Children[0])
				decode(buffer, field.Children, count)
			}
		}
	}
}

// encode transforms the message into a byte slice, which may be sent to a connection.
func encode(ms Message) ([]byte, error) {
	buffer := bytes.Buffer{}
	encodeLoop(&buffer, [][]*Field{ms.Fields}, 1)
	data := buffer.Bytes()

	// Find and write the message length
	byteOffset := int32(0)
	for i, field := range ms.Fields {
		if field.Tags&(MessageLengthInclusive|MessageLengthExclusive) > 0 {
			typeLength := int32(0)
			// Exclusive lengths must take their own type size into account
			if field.Tags&MessageLengthExclusive > 0 {
				switch field.Type {
				case Byte1, Int8:
					typeLength = 1
				case Int16:
					typeLength = 2
				case Int32:
					typeLength = 4
				}
			}
			messageLength := int32(len(data)) - byteOffset - typeLength
			switch field.Type {
			case Byte1, Int8:
				data[byteOffset] = byte(messageLength)
			case Int16:
				binary.BigEndian.PutUint16(data[byteOffset:], uint16(messageLength))
			case Int32:
				binary.BigEndian.PutUint32(data[byteOffset:], uint32(messageLength))
			default:
				panic("invalid type for message length")
			}
			break
		}

		// Advance the offset
		switch field.Type {
		case Byte1, Int8:
			byteOffset += 1
		case ByteN:
			if i > 0 && ms.Fields[i-1].Tags&ByteCount > 0 {
				byteOffset += ms.Fields[i-1].Data.(int32)
			} else {
				byteOffset = int32(len(data)) // Last field, so we can set it to the remaining data
			}
		case Int16:
			byteOffset += 2
		case Int32:
			byteOffset += 4
		case String:
			found := false
			for bufferIdx := range data[byteOffset:] {
				if data[bufferIdx] == 0 {
					found = true
					byteOffset += int32(bufferIdx)
					//TODO: is this the correct place to put this? investigate/test
					if field.Tags&ExcludeTerminator == 0 {
						byteOffset += 1
					}
					break
				}
			}
			if !found {
				panic("terminating zero not found for string")
			}
		default:
			panic("message type has not been defined")
		}
	}
	return data, nil
}

// encodeLoop is the inner recursive loop of encode, which writes the given fields into the buffer. The iteration
// count determines how many times the fields are looped over.
func encodeLoop(buffer *bytes.Buffer, fields [][]*Field, iterations int32) {
	for iteration := int32(0); iteration < iterations; iteration++ {
		for _, field := range fields[iteration] {
			switch field.Type {
			case Byte1:
				_ = binary.Write(buffer, binary.BigEndian, byte(field.Data.(int32)))
			case ByteN:
				buffer.Write(field.Data.([]byte))
			case Int8:
				_ = binary.Write(buffer, binary.BigEndian, int8(field.Data.(int32)))
			case Int16:
				_ = binary.Write(buffer, binary.BigEndian, int16(field.Data.(int32)))
			case Int32:
				_ = binary.Write(buffer, binary.BigEndian, field.Data.(int32))
			case String:
				buffer.WriteString(field.Data.(string))
				if field.Tags&ExcludeTerminator == 0 {
					buffer.WriteByte(0)
				}
			default:
				panic("message type has not been defined")
			}

			if len(field.Children) > 0 {
				encodeLoop(buffer, field.Children, field.Data.(int32))
			}
		}
	}
}
