// Copyright 2023 Dolthub, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package messages

import (
	"bytes"
	"encoding/binary"
	"errors"
	"net"
)

// Receive returns a MessageType from the given buffer, generally generated by the client in the main read loop of a
// connection.
func Receive(buffer []byte) (MessageType, bool, error) {
	if len(buffer) == 0 {
		return nil, false, nil
	}
	message, ok := allMessageHeaders[buffer[0]]
	if !ok {
		return nil, false, nil
	}
	outMessage, err := ReceiveInto(buffer, message)
	return outMessage, true, err
}

// ReceiveInto writes the contents of the buffer into the given MessageType.
func ReceiveInto[T MessageType](buffer []byte, message T) (out T, err error) {
	defaultMessage := message.defaultMessage()
	fields := defaultMessage.Copy().Fields
	if err = decode(&decodeBuffer{buffer}, [][]*Field{fields}, 1); err != nil {
		return out, err
	}
	decodedMessage, err := message.decode(Message{defaultMessage.Name, fields, defaultMessage.info, false})
	if err != nil {
		return out, err
	}
	return decodedMessage.(T), nil
}

// Send sends the given message over the connection.
func Send(conn net.Conn, message MessageType) error {
	encodedMessage, err := message.encode()
	if err != nil {
		return err
	}
	data, err := encode(encodedMessage)
	if err != nil {
		return err
	}
	_, err = conn.Write(data)
	return err
}

// decodeBuffer just provides an easy way to reference the same buffer, so that decode can modify its length.
type decodeBuffer struct {
	data []byte
}

// decode writes the contents of the buffer into the given fields. The iteration count determines how many times the
// fields will be looped over.
func decode(buffer *decodeBuffer, fields [][]*Field, iterations int32) error {
	for iteration := int32(0); iteration < iterations; iteration++ {
		for i, field := range fields[iteration] {
			if len(buffer.data) == 0 {
				return errors.New("buffer too small")
			}
			switch field.Type {
			case Byte1, Int8:
				field.Data = int32(buffer.data[0])
				buffer.data = buffer.data[1:]
			case ByteN:
				if i > 0 && fields[iteration][i-1].Tags&ByteCount > 0 {
					byteCount := fields[iteration][i-1].Data.(int32)
					data := make([]byte, byteCount)
					copy(data, buffer.data)
					field.Data = data
					buffer.data = buffer.data[byteCount:]
				} else {
					data := make([]byte, len(buffer.data))
					copy(data, buffer.data)
					field.Data = data
					buffer.data = nil
				}
			case Int16:
				field.Data = int32(binary.BigEndian.Uint16(buffer.data))
				buffer.data = buffer.data[2:]
			case Int32:
				field.Data = int32(binary.BigEndian.Uint32(buffer.data))
				buffer.data = buffer.data[4:]
			case String:
				found := false
				for bufferIdx := range buffer.data {
					if buffer.data[bufferIdx] == 0 {
						field.Data = string(buffer.data[:bufferIdx])
						buffer.data = buffer.data[bufferIdx:]
						if field.Tags&ExcludeTerminator == 0 {
							buffer.data = buffer.data[1:]
						}
						found = true
						break
					}
				}
				if !found {
					return errors.New("terminating zero not found for string")
				}
			case Repeated:
				// Track if we've decoded at least once, so that we only update the count if we've decoded something
				decodedAtLeastOnce := false
				originalChildren := field.Copy().Children[0]
				for i := 1; len(buffer.data) > 1; i++ {
					field.extend(i, originalChildren)
					if err := decode(buffer, field.Children[len(field.Children)-1:], 1); err != nil {
						return err
					}
					decodedAtLeastOnce = true
				}
				// Some messages append a NULL byte at the end of the sequence, so we should handle that.
				// If we have a single Byte1/Int8 child, then we assume that this isn't a NULL byte, but a valid value.
				if len(buffer.data) == 1 && buffer.data[0] == 0 {
					if len(originalChildren) == 1 && (originalChildren[0].Type == Byte1 || originalChildren[0].Type == Int8) {
						field.extend(len(field.Children)+1, originalChildren)
						if err := decode(buffer, field.Children[len(field.Children)-1:], 1); err != nil {
							return err
						}
						decodedAtLeastOnce = true
					} else {
						buffer.data = buffer.data[1:]
					}
				}
				if decodedAtLeastOnce {
					field.Data = int32(len(field.Children))
				}
			default:
				panic("message type has not been defined")
			}

			if field.Tags&MessageLengthInclusive > 0 {
				messageLength := field.Data.(int32)
				switch field.Type {
				case Byte1, Int8:
					messageLength -= 1
				case Int16:
					messageLength -= 2
				case Int32:
					messageLength -= 4
				}
				buffer.data = buffer.data[:messageLength]
			} else if field.Tags&MessageLengthExclusive > 0 {
				buffer.data = buffer.data[:field.Data.(int32)]
			}
			if len(field.Children) > 0 && field.Type != Repeated {
				count, ok := field.Data.(int32)
				if !ok {
					return errors.New("non-integer is being used as a count")
				}
				field.extend(int(count), field.Children[0])
				if err := decode(buffer, field.Children, count); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

// encode transforms the message into a byte slice, which may be sent to a connection.
func encode(ms Message) ([]byte, error) {
	buffer := bytes.Buffer{}
	encodeLoop(&buffer, [][]*Field{ms.Fields}, 1)
	data := buffer.Bytes()

	// Find and write the message length
	byteOffset := int32(0)
	for i, field := range ms.Fields {
		if field.Tags&(MessageLengthInclusive|MessageLengthExclusive) > 0 {
			typeLength := int32(0)
			// Exclusive lengths must take their own type size into account and exclude them from the overall length
			if field.Tags&MessageLengthExclusive > 0 {
				switch field.Type {
				case Byte1, Int8:
					typeLength = 1
				case Int16:
					typeLength = 2
				case Int32:
					typeLength = 4
				}
			}
			messageLength := int32(len(data)) - byteOffset - typeLength
			switch field.Type {
			case Byte1, Int8:
				data[byteOffset] = byte(messageLength)
			case Int16:
				binary.BigEndian.PutUint16(data[byteOffset:], uint16(messageLength))
			case Int32:
				binary.BigEndian.PutUint32(data[byteOffset:], uint32(messageLength))
			default:
				panic("invalid type for message length")
			}
			break
		}

		// Advance the offset
		switch field.Type {
		case Byte1, Int8:
			byteOffset += 1
		case ByteN:
			if i > 0 && ms.Fields[i-1].Tags&ByteCount > 0 {
				byteOffset += ms.Fields[i-1].Data.(int32)
			} else {
				byteOffset = int32(len(data)) // Last field, so we can set it to the remaining data
			}
		case Int16:
			byteOffset += 2
		case Int32:
			byteOffset += 4
		case String:
			found := false
			for bufferIdx := range data[byteOffset:] {
				if data[bufferIdx] == 0 {
					found = true
					byteOffset += int32(bufferIdx)
					//TODO: is this the correct place to put this? investigate/test
					if field.Tags&ExcludeTerminator == 0 {
						byteOffset += 1
					}
					break
				}
			}
			if !found {
				panic("terminating zero not found for string")
			}
		case Repeated:
			byteOffset = int32(len(data)) // Last field, so we can set it to the remaining data
		default:
			panic("message type has not been defined")
		}
	}
	return data, nil
}

// encodeLoop is the inner recursive loop of encode, which writes the given fields into the buffer. The iteration
// count determines how many times the fields are looped over.
func encodeLoop(buffer *bytes.Buffer, fields [][]*Field, iterations int32) {
	for iteration := int32(0); iteration < iterations; iteration++ {
		for _, field := range fields[iteration] {
			switch field.Type {
			case Byte1:
				_ = binary.Write(buffer, binary.BigEndian, byte(field.Data.(int32)))
			case ByteN:
				buffer.Write(field.Data.([]byte))
			case Int8:
				_ = binary.Write(buffer, binary.BigEndian, int8(field.Data.(int32)))
			case Int16:
				_ = binary.Write(buffer, binary.BigEndian, int16(field.Data.(int32)))
			case Int32:
				_ = binary.Write(buffer, binary.BigEndian, field.Data.(int32))
			case String:
				buffer.WriteString(field.Data.(string))
				if field.Tags&ExcludeTerminator == 0 {
					buffer.WriteByte(0)
				}
			case Repeated:
				// We don't write anything for repeated fields, since they repeat their children until the end
			default:
				panic("message type has not been defined")
			}

			if len(field.Children) > 0 {
				encodeLoop(buffer, field.Children, field.Data.(int32))
			}
		}
	}
}
